<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>alphaTorrent: tracker Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">alphaTorrent
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tracker Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Contains all tracker method and structures.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtracker_1_1TParameter.html">TParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct contains all param to send to the tracker.  <a href="structtracker_1_1TParameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5c98069e9e5f8fbee2ac2ee82144347d"><td class="memItemLeft" align="right" valign="top"><a id="a5c98069e9e5f8fbee2ac2ee82144347d"></a>
typedef vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TList</b></td></tr>
<tr class="separator:a5c98069e9e5f8fbee2ac2ee82144347d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adad29535063afb92161f98de28f9af30"><td class="memItemLeft" align="right" valign="top"><a id="adad29535063afb92161f98de28f9af30"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>event_type</b> { <b>STARTED</b>, 
<b>STOPPED</b>
 }</td></tr>
<tr class="separator:adad29535063afb92161f98de28f9af30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afbc30ba2b5f62968e92fedaaa8eab454"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#afbc30ba2b5f62968e92fedaaa8eab454">start_tracker_request</a> (<a class="el" href="structtracker_1_1TParameter.html">TParameter</a> *param, const TList &amp;tracker_list, <a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a> peer_list)</td></tr>
<tr class="memdesc:afbc30ba2b5f62968e92fedaaa8eab454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send request to each tracker in tracker_list.  <a href="#afbc30ba2b5f62968e92fedaaa8eab454">More...</a><br /></td></tr>
<tr class="separator:afbc30ba2b5f62968e92fedaaa8eab454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ce1ce0570dd4742e06b6941f63dbe4"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#ab1ce1ce0570dd4742e06b6941f63dbe4">remove_duplicate_peers</a> (<a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a> &amp;peer_list)</td></tr>
<tr class="memdesc:ab1ce1ce0570dd4742e06b6941f63dbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicate peers from a peer_list.  <a href="#ab1ce1ce0570dd4742e06b6941f63dbe4">More...</a><br /></td></tr>
<tr class="separator:ab1ce1ce0570dd4742e06b6941f63dbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13f3471f16db9505c2853f4e1bde3aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#ab13f3471f16db9505c2853f4e1bde3aa">process_tracker_request</a> (const string &amp;tracker_url, const <a class="el" href="structtracker_1_1TParameter.html">TParameter</a> *param, <a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a> peer_list)</td></tr>
<tr class="memdesc:ab13f3471f16db9505c2853f4e1bde3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main http tracker manager.  <a href="#ab13f3471f16db9505c2853f4e1bde3aa">More...</a><br /></td></tr>
<tr class="separator:ab13f3471f16db9505c2853f4e1bde3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0158d3629445e060aef8608eefff5f09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a0158d3629445e060aef8608eefff5f09">urlencode_paramenter</a> (<a class="el" href="structtracker_1_1TParameter.html">TParameter</a> *param, CURL *curl)</td></tr>
<tr class="separator:a0158d3629445e060aef8608eefff5f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c22f265981fba0a5dad14d6d3d516a"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a60c22f265981fba0a5dad14d6d3d516a">url_builder</a> (const string &amp;tracker_url, const <a class="el" href="structtracker_1_1TParameter.html">TParameter</a> &amp;t_param, event_type event, const string &amp;tracker_key, CURL *curl, bool tls)</td></tr>
<tr class="memdesc:a60c22f265981fba0a5dad14d6d3d516a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the tracker GET request.  <a href="#a60c22f265981fba0a5dad14d6d3d516a">More...</a><br /></td></tr>
<tr class="separator:a60c22f265981fba0a5dad14d6d3d516a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6486613c238a5415481c5ae6234aa91b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a6486613c238a5415481c5ae6234aa91b">writeFunction</a> (void *ptr, size_t size, size_t nmemb, std::string *data)</td></tr>
<tr class="memdesc:a6486613c238a5415481c5ae6234aa91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manage the curl response.  <a href="#a6486613c238a5415481c5ae6234aa91b">More...</a><br /></td></tr>
<tr class="separator:a6486613c238a5415481c5ae6234aa91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53773ba678237b3a3675d87a66c68aee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a53773ba678237b3a3675d87a66c68aee">tracker_send_request</a> (shared_ptr&lt; string &gt; url, string *response, CURL *curl)</td></tr>
<tr class="memdesc:a53773ba678237b3a3675d87a66c68aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the http(s) request and print the response.  <a href="#a53773ba678237b3a3675d87a66c68aee">More...</a><br /></td></tr>
<tr class="separator:a53773ba678237b3a3675d87a66c68aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ceea8b68053534e15cb3ac3fd1702fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a2ceea8b68053534e15cb3ac3fd1702fb">check_url</a> (const string &amp;url, CURL *curl)</td></tr>
<tr class="memdesc:a2ceea8b68053534e15cb3ac3fd1702fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the url is valid.  <a href="#a2ceea8b68053534e15cb3ac3fd1702fb">More...</a><br /></td></tr>
<tr class="separator:a2ceea8b68053534e15cb3ac3fd1702fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31ad1c263b18cd7885f587823514abe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#ac31ad1c263b18cd7885f587823514abe">process_tracker_response</a> (string *response, <a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a> peer_list)</td></tr>
<tr class="memdesc:ac31ad1c263b18cd7885f587823514abe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse tracker response and extract peers.  <a href="#ac31ad1c263b18cd7885f587823514abe">More...</a><br /></td></tr>
<tr class="separator:ac31ad1c263b18cd7885f587823514abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd84715185a5e4a1351b77af43e7e01c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#afd84715185a5e4a1351b77af43e7e01c">scrape_request</a> (string &amp;url, const <a class="el" href="structtracker_1_1TParameter.html">TParameter</a> &amp;param, string *response, CURL *curl)</td></tr>
<tr class="memdesc:afd84715185a5e4a1351b77af43e7e01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a scrape request from a tracker url.  <a href="#afd84715185a5e4a1351b77af43e7e01c">More...</a><br /></td></tr>
<tr class="separator:afd84715185a5e4a1351b77af43e7e01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1983d55d0f9efca5948d0a69d25ba6"><td class="memItemLeft" align="right" valign="top">shared_ptr&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#ace1983d55d0f9efca5948d0a69d25ba6">get_scrape_url</a> (const string &amp;url)</td></tr>
<tr class="memdesc:ace1983d55d0f9efca5948d0a69d25ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get tracker url and return the scraped version of it.  <a href="#ace1983d55d0f9efca5948d0a69d25ba6">More...</a><br /></td></tr>
<tr class="separator:ace1983d55d0f9efca5948d0a69d25ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722dfd0ec93e84bbbd448d2c9d6a9f1b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a722dfd0ec93e84bbbd448d2c9d6a9f1b">create_tracker_key</a> ()</td></tr>
<tr class="memdesc:a722dfd0ec93e84bbbd448d2c9d6a9f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the key needed for tracker protocol.  <a href="#a722dfd0ec93e84bbbd448d2c9d6a9f1b">More...</a><br /></td></tr>
<tr class="separator:a722dfd0ec93e84bbbd448d2c9d6a9f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d52cf6dd86f2a26a719e285097c805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a38d52cf6dd86f2a26a719e285097c805">parse_dict_peer</a> (<a class="el" href="structbe__node.html">be_node</a> *node, <a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a> peer_list)</td></tr>
<tr class="memdesc:a38d52cf6dd86f2a26a719e285097c805"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a non compact tracker response.  <a href="#a38d52cf6dd86f2a26a719e285097c805">More...</a><br /></td></tr>
<tr class="separator:a38d52cf6dd86f2a26a719e285097c805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237de4c8b0282af2d59cd5d0b7bfd1fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#a237de4c8b0282af2d59cd5d0b7bfd1fd">parse_binary_peers</a> (const string &amp;resp, <a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a> peer_list)</td></tr>
<tr class="memdesc:a237de4c8b0282af2d59cd5d0b7bfd1fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a binary tracker response.  <a href="#a237de4c8b0282af2d59cd5d0b7bfd1fd">More...</a><br /></td></tr>
<tr class="separator:a237de4c8b0282af2d59cd5d0b7bfd1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae542bb4bf17f34b8cadc3a4ae2f5ced2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetracker.html#ae542bb4bf17f34b8cadc3a4ae2f5ced2">is_compact_response</a> (const string *response)</td></tr>
<tr class="memdesc:ae542bb4bf17f34b8cadc3a4ae2f5ced2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a response is in a compact format.  <a href="#ae542bb4bf17f34b8cadc3a4ae2f5ced2">More...</a><br /></td></tr>
<tr class="separator:ae542bb4bf17f34b8cadc3a4ae2f5ced2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3426052cbc1ef8f22a629e4468cd70e6"><td class="memItemLeft" align="right" valign="top"><a id="a3426052cbc1ef8f22a629e4468cd70e6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>scrape_request</b> (string &amp;url, string *response, CURL *curl=NULL)</td></tr>
<tr class="separator:a3426052cbc1ef8f22a629e4468cd70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a53fb7c4cde6ffdc06505609407c563ad"><td class="memItemLeft" align="right" valign="top"><a id="a53fb7c4cde6ffdc06505609407c563ad"></a>
boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>peer_list_mutex</b></td></tr>
<tr class="separator:a53fb7c4cde6ffdc06505609407c563ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Contains all tracker method and structures. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2ceea8b68053534e15cb3ac3fd1702fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ceea8b68053534e15cb3ac3fd1702fb">&#9670;&nbsp;</a></span>check_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tracker::check_url </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CURL *&#160;</td>
          <td class="paramname"><em>curl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the url is valid. </p>
<dl class="section warning"><dt>Warning</dt><dd>Untested</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*url</td><td>: URL to check </td></tr>
    <tr><td class="paramname">*curl</td><td>: (Optional) instance of curl library</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(true) if it's valid, (false) otherwise </dd></dl>

</div>
</div>
<a id="a722dfd0ec93e84bbbd448d2c9d6a9f1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722dfd0ec93e84bbbd448d2c9d6a9f1b">&#9670;&nbsp;</a></span>create_tracker_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string tracker::create_tracker_key </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the key needed for tracker protocol. </p>
<dl class="section return"><dt>Returns</dt><dd>string cointaining the key </dd></dl>

</div>
</div>
<a id="ace1983d55d0f9efca5948d0a69d25ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1983d55d0f9efca5948d0a69d25ba6">&#9670;&nbsp;</a></span>get_scrape_url()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; string &gt; tracker::get_scrape_url </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>url</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get tracker url and return the scraped version of it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>: the url(annouunce version) of the tracker </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the new url or nullptr if the tracker doesn't support scraping </dd></dl>

</div>
</div>
<a id="ae542bb4bf17f34b8cadc3a4ae2f5ced2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae542bb4bf17f34b8cadc3a4ae2f5ced2">&#9670;&nbsp;</a></span>is_compact_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tracker::is_compact_response </td>
          <td>(</td>
          <td class="paramtype">const string *&#160;</td>
          <td class="paramname"><em>response</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a response is in a compact format. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Improve and re-test this function</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*response</td><td>: the response to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>: true if it's compact, otherwise false </dd></dl>

</div>
</div>
<a id="a237de4c8b0282af2d59cd5d0b7bfd1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237de4c8b0282af2d59cd5d0b7bfd1fd">&#9670;&nbsp;</a></span>parse_binary_peers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracker::parse_binary_peers </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>resp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a>&#160;</td>
          <td class="paramname"><em>peer_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a binary tracker response. </p>
<p>This function parse a compact tracker's response according to the following protocol</p>
<p>peers: (binary model) Instead of using the dictionary model described above, the peers value may be a string consisting of multiples of 6 bytes. First 4 bytes are the IP address and last 2 bytes are the port number. All in network (big endian) notation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resp</td><td>the response to parse </td></tr>
    <tr><td class="paramname">peer_list</td><td>the structure where to store extracted peers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38d52cf6dd86f2a26a719e285097c805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d52cf6dd86f2a26a719e285097c805">&#9670;&nbsp;</a></span>parse_dict_peer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tracker::parse_dict_peer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbe__node.html">be_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a>&#160;</td>
          <td class="paramname"><em>peer_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a non compact tracker response. </p>
<p>This function parse a non compact tracker's response according to the following protocol<br />
 peers: (dictionary model) The value is a list of dictionaries, each with the following keys:<br />
peer id: peer's self-selected ID, as described above for the tracker request (string)<br />
ip: peer's IP address either IPv6 (hexed) or IPv4 (dotted quad) or DNS name (string)<br />
port: peer's port number (integer)<br />
 </p><dl class="bug"><dt><b><a class="el" href="bug.html#_bug000003">Bug:</a></b></dt><dd>The address of the peer could be of three types : IPv6, DNS and IPv6. Currently just IPv4 is supported. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>Add support for IPv6 and DNS addresses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>the bencoded node containing the list of dictionaries</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, &lt; 0 otherwise </dd></dl>

</div>
</div>
<a id="ab13f3471f16db9505c2853f4e1bde3aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab13f3471f16db9505c2853f4e1bde3aa">&#9670;&nbsp;</a></span>process_tracker_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tracker::process_tracker_request </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tracker_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtracker_1_1TParameter.html">TParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a>&#160;</td>
          <td class="paramname"><em>peer_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main http tracker manager. </p>
<p>Manage the entire tracker request : it craft the "announce" request and parse the response to extract peers data, that subsequently is pushed inside peer_list</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker_url</td><td>: the url of the tracker to contact </td></tr>
    <tr><td class="paramname">param</td><td>: the torrent file param </td></tr>
    <tr><td class="paramname">peer_list</td><td>: a pointer to the vector where to store peers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac31ad1c263b18cd7885f587823514abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac31ad1c263b18cd7885f587823514abe">&#9670;&nbsp;</a></span>process_tracker_response()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tracker::process_tracker_response </td>
          <td>(</td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a>&#160;</td>
          <td class="paramname"><em>peer_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse tracker response and extract peers. </p>
<p>Decode the bencoded tracker response and detect if the response is "compact" of "dictionary" After calling the appropriate function the PeerList is populated with extracted peers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">response</td><td></td></tr>
    <tr><td class="paramname">peer_list</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 0 on success, &lt;0 otherwise </dd></dl>

</div>
</div>
<a id="ab1ce1ce0570dd4742e06b6941f63dbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ce1ce0570dd4742e06b6941f63dbe4">&#9670;&nbsp;</a></span>remove_duplicate_peers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint tracker::remove_duplicate_peers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a> &amp;&#160;</td>
          <td class="paramname"><em>peer_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicate peers from a peer_list. </p>
<p>Take a PeerList and delete al duplicate elements. Following this response (<a href="https://stackoverflow.com/questions/1041620/whats-the-most-efficient-way-to-erase-duplicates-and-sort-a-vector">https://stackoverflow.com/questions/1041620/whats-the-most-efficient-way-to-erase-duplicates-and-sort-a-vector</a>) is better to convert the vector to a set and then convert back if the number element is low </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>The test was with integers, re-test with <a class="el" href="structpwp_1_1peer.html">pwp::peer</a></dd></dl>
<p>/warning Unimplemented function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peer_list</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint the peers number after the processing </dd></dl>

</div>
</div>
<a id="afd84715185a5e4a1351b77af43e7e01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd84715185a5e4a1351b77af43e7e01c">&#9670;&nbsp;</a></span>scrape_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tracker::scrape_request </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtracker_1_1TParameter.html">TParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CURL *&#160;</td>
          <td class="paramname"><em>curl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a scrape request from a tracker url. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">url</td><td>tracker url </td></tr>
    <tr><td class="paramname">param</td><td></td></tr>
    <tr><td class="paramname">response</td><td>reference to a buffer that will store the response </td></tr>
    <tr><td class="paramname">curl</td><td>(Optional) instance of the curl library </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="afbc30ba2b5f62968e92fedaaa8eab454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc30ba2b5f62968e92fedaaa8eab454">&#9670;&nbsp;</a></span>start_tracker_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tracker::start_tracker_request </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtracker_1_1TParameter.html">TParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TList &amp;&#160;</td>
          <td class="paramname"><em>tracker_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacepwp.html#ad07fa6df116b205302ad5ec172277184">pwp::PeerList</a>&#160;</td>
          <td class="paramname"><em>peer_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send request to each tracker in tracker_list. </p>
<p>Read from config file (to implement) the port. Then analize the files and fill the tracker parameter structure.</p>
<p>The appropriate tracker protocol is then choosed and executed; the parsed peers are added to the peer_list (passed by argument).</p>
<p>The config file and the "uploaded" and "downloaded" param are still unimplemented. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Read che config parameter from a config file</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*param</td><td>the struct containing the tracker parameter </td></tr>
    <tr><td class="paramname">peer_id</td><td>the client generated id </td></tr>
    <tr><td class="paramname">peer_list</td><td>vector where to store received peers </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53773ba678237b3a3675d87a66c68aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53773ba678237b3a3675d87a66c68aee">&#9670;&nbsp;</a></span>tracker_send_request()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tracker::tracker_send_request </td>
          <td>(</td>
          <td class="paramtype">shared_ptr&lt; string &gt;&#160;</td>
          <td class="paramname"><em>url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string *&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CURL *&#160;</td>
          <td class="paramname"><em>curl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the http(s) request and print the response. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*url</td><td>: the url to contact (with the GET parameter) </td></tr>
    <tr><td class="paramname">curl</td><td>: (Optional) the instance of the curl lib</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if it's a success, &lt;0 otherwise; </dd></dl>

</div>
</div>
<a id="a60c22f265981fba0a5dad14d6d3d516a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c22f265981fba0a5dad14d6d3d516a">&#9670;&nbsp;</a></span>url_builder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">shared_ptr&lt; string &gt; tracker::url_builder </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tracker_url</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtracker_1_1TParameter.html">TParameter</a> &amp;&#160;</td>
          <td class="paramname"><em>t_param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">event_type&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tracker_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CURL *&#160;</td>
          <td class="paramname"><em>curl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tls</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the tracker GET request. </p>
<p>An HTTP GET request is crafted using tracker's url and request parameters</p>
<p>In case of error the request is equal to ""</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd><p class="startdd">Improve this function parmeters, since trakcer_url is already inside <a class="el" href="structtracker_1_1TParameter.html" title="Struct contains all param to send to the tracker. ">TParameter</a> </p>
<p>Check if tracker_url is a proper url by validating it with regex </p>
<p class="enddd">Manage errors</p>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tracker_url</td><td>tracker's url </td></tr>
    <tr><td class="paramname">param</td><td>param to send to the tracker </td></tr>
    <tr><td class="paramname">curl</td><td>: (Optional) curl library instance </td></tr>
    <tr><td class="paramname">tls</td><td>: (Optional) specify if https should be used; default = false</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a shared pointer to a string containing the url </dd></dl>

</div>
</div>
<a id="a0158d3629445e060aef8608eefff5f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0158d3629445e060aef8608eefff5f09">&#9670;&nbsp;</a></span>urlencode_paramenter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tracker::urlencode_paramenter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtracker_1_1TParameter.html">TParameter</a> *&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CURL *&#160;</td>
          <td class="paramname"><em>curl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function take the tracker's param and urlencode the info_hash and the peer_id, the other parameters are left untouched</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">*param</td><td>pointer to a struct containing parameters </td></tr>
    <tr><td class="paramname">*curl</td><td>(Optional) instance of curl library</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success, &lt; 0 otherwise </dd></dl>

</div>
</div>
<a id="a6486613c238a5415481c5ae6234aa91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6486613c238a5415481c5ae6234aa91b">&#9670;&nbsp;</a></span>writeFunction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tracker::writeFunction </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Manage the curl response. </p>
<p>Default function (take from curl example) that write the response into "data" </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
