\hypertarget{namespacepwp}{}\section{pwp Namespace Reference}
\label{namespacepwp}\index{pwp@{pwp}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structpwp_1_1client__state}{client\+\_\+state}
\item 
struct \hyperlink{structpwp_1_1peer}{peer}
\item 
struct \hyperlink{structpwp_1_1peer__connection}{peer\+\_\+connection}
\item 
struct \hyperlink{structpwp_1_1peer__state}{peer\+\_\+state}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef std\+::shared\+\_\+ptr$<$ std\+::vector$<$ \hyperlink{structpwp_1_1peer}{pwp\+::peer} $>$ $>$ \hyperlink{namespacepwp_ad07fa6df116b205302ad5ec172277184}{Peer\+List}
\item 
\mbox{\Hypertarget{namespacepwp_a174e8f020062fa10258b0d28f00d79ff}\label{namespacepwp_a174e8f020062fa10258b0d28f00d79ff}} 
typedef std\+::shared\+\_\+ptr$<$ std\+::vector$<$ \hyperlink{structpwp_1_1peer__connection}{pwp\+::peer\+\_\+connection} $>$ $>$ {\bfseries Peer\+Connected}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{namespacepwp_ae8331eb5e3c98deddc6022dad92352f6}{remove\+\_\+invalid\+\_\+peer} (\hyperlink{namespacepwp_ad07fa6df116b205302ad5ec172277184}{pwp\+::\+Peer\+List} peer\+\_\+list)
\begin{DoxyCompactList}\small\item\em Find invalid peers and remove it. \end{DoxyCompactList}\item 
int \hyperlink{namespacepwp_a73acf05b954e39825a88036d5793db6b}{create\+\_\+socket} (\hyperlink{structpwp_1_1peer__connection}{pwp\+::peer\+\_\+connection} \&peer\+\_\+conn\+\_\+p)
\begin{DoxyCompactList}\small\item\em Create the socket and connect to the peer. \end{DoxyCompactList}\item 
void \hyperlink{namespacepwp_a62060bdcdc80541b0892e26fbeab1e91}{pwp\+\_\+protocol\+\_\+manager} (\hyperlink{structpwp_1_1peer}{pwp\+::peer} peer\+\_\+, const std\+::vector$<$ uint8\+\_\+t $>$ \&handshake, const char $\ast$info\+\_\+hash, \hyperlink{structtorr_1_1Torrent}{Torrent} \&torrent)
\begin{DoxyCompactList}\small\item\em Manager of the entire P\+WP protocol. \end{DoxyCompactList}\item 
void \hyperlink{namespacepwp_a6062876f4d4d4d6ee19341a79a797864}{build\+\_\+handshake} (char $\ast$info\+\_\+hash, std\+::vector$<$ uint8\+\_\+t $>$ \&handshake)
\begin{DoxyCompactList}\small\item\em Create the handshake for a file. \end{DoxyCompactList}\item 
int \hyperlink{namespacepwp_a851ddc0e8fb2eb0a86317cc944c4a927}{send\+\_\+handshake} (\hyperlink{structpwp_1_1peer__connection}{pwp\+::peer\+\_\+connection} \&peerc\+\_\+t, const std\+::vector$<$ uint8\+\_\+t $>$ handshake, std\+::vector$<$ uint8\+\_\+t $>$ \&response)
\item 
void \hyperlink{namespacepwp_ada6a8613896dbbfd6fba63b17d51684c}{get\+\_\+peer\+\_\+id} (string $\ast$id)
\begin{DoxyCompactList}\small\item\em Put into \char`\"{}id\char`\"{} the string that conrespond to the client ID. \end{DoxyCompactList}\item 
int \hyperlink{namespacepwp_a58c780495f2139a56b95662dc7c0345f}{verify\+\_\+handshake} (const vector$<$ uint8\+\_\+t $>$ handshake, size\+\_\+t len, const \hyperlink{structpwp_1_1peer}{pwp\+::peer} t\+\_\+peer, const char $\ast$info\+\_\+hash)
\item 
\mbox{\Hypertarget{namespacepwp_ab82c0d015f6ba23e766c4b942a125b5f}\label{namespacepwp_ab82c0d015f6ba23e766c4b942a125b5f}} 
void {\bfseries manage\+\_\+peer\+\_\+connection} (\hyperlink{namespacepwp_ad07fa6df116b205302ad5ec172277184}{pwp\+::\+Peer\+List} peer\+\_\+list, char $\ast$info\+\_\+hash)
\item 
\mbox{\Hypertarget{namespacepwp_a5f03cde749af88a393c999545830b192}\label{namespacepwp_a5f03cde749af88a393c999545830b192}} 
void {\bfseries get\+\_\+peer\+\_\+id} (std\+::string $\ast$id)
\item 
\mbox{\Hypertarget{namespacepwp_ae2eeca61e271fabff5fa45308396009e}\label{namespacepwp_ae2eeca61e271fabff5fa45308396009e}} 
void {\bfseries handshake\+\_\+request\+\_\+manager} (const std\+::array$<$ char, 256 $>$ \&handshake, const \hyperlink{structpwp_1_1peer}{pwp\+::peer} t\+\_\+peer, const char $\ast$info\+\_\+hash, pwp\+::\+Peer\+Connected valid\+\_\+peer)
\item 
\mbox{\Hypertarget{namespacepwp_aed118903b8345e62507ade49c6032d32}\label{namespacepwp_aed118903b8345e62507ade49c6032d32}} 
int {\bfseries verify\+\_\+handshake} (const std\+::vector$<$ uint8\+\_\+t $>$ handshake, size\+\_\+t len, const \hyperlink{structpwp_1_1peer}{pwp\+::peer} t\+\_\+peer, const char $\ast$info\+\_\+hash)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Namespace used to define all peer\textquotesingle{}s related data and P\+WP protocol 

\subsection{Typedef Documentation}
\mbox{\Hypertarget{namespacepwp_ad07fa6df116b205302ad5ec172277184}\label{namespacepwp_ad07fa6df116b205302ad5ec172277184}} 
\index{pwp@{pwp}!Peer\+List@{Peer\+List}}
\index{Peer\+List@{Peer\+List}!pwp@{pwp}}
\subsubsection{\texorpdfstring{Peer\+List}{PeerList}}
{\footnotesize\ttfamily typedef std\+::shared\+\_\+ptr$<$std\+::vector$<$\hyperlink{structpwp_1_1peer}{pwp\+::peer}$>$ $>$ \hyperlink{namespacepwp_ad07fa6df116b205302ad5ec172277184}{pwp\+::\+Peer\+List}}

peer list extracted from tracker 

\subsection{Function Documentation}
\mbox{\Hypertarget{namespacepwp_a6062876f4d4d4d6ee19341a79a797864}\label{namespacepwp_a6062876f4d4d4d6ee19341a79a797864}} 
\index{pwp@{pwp}!build\+\_\+handshake@{build\+\_\+handshake}}
\index{build\+\_\+handshake@{build\+\_\+handshake}!pwp@{pwp}}
\subsubsection{\texorpdfstring{build\+\_\+handshake()}{build\_handshake()}}
{\footnotesize\ttfamily void pwp\+::build\+\_\+handshake (\begin{DoxyParamCaption}\item[{char $\ast$}]{info\+\_\+hash,  }\item[{std\+::vector$<$ uint8\+\_\+t $>$ \&}]{handshake }\end{DoxyParamCaption})}



Create the handshake for a file. 


\begin{DoxyParams}{Parameters}
{\em info\+\_\+hash} & the info\+\_\+hash of the file \\
\hline
{\em handshake} & the destination array for the handshake \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacepwp_a73acf05b954e39825a88036d5793db6b}\label{namespacepwp_a73acf05b954e39825a88036d5793db6b}} 
\index{pwp@{pwp}!create\+\_\+socket@{create\+\_\+socket}}
\index{create\+\_\+socket@{create\+\_\+socket}!pwp@{pwp}}
\subsubsection{\texorpdfstring{create\+\_\+socket()}{create\_socket()}}
{\footnotesize\ttfamily int pwp\+::create\+\_\+socket (\begin{DoxyParamCaption}\item[{\hyperlink{structpwp_1_1peer__connection}{pwp\+::peer\+\_\+connection} \&}]{peer\+\_\+conn\+\_\+p }\end{DoxyParamCaption})}



Create the socket and connect to the peer. 

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Error Code }&\textbf{ Meaning  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Error Code }&\textbf{ Meaning  }\\\cline{1-2}
\endhead
-\/1 &Connection Closed \\\cline{1-2}
-\/2 &Generic Error (see the output) \\\cline{1-2}
-\/3 &Invalid Address \\\cline{1-2}
\end{longtabu}



\begin{DoxyParams}{Parameters}
{\em \hyperlink{structpwp_1_1peer__connection}{peer\+\_\+connection}} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacepwp_ada6a8613896dbbfd6fba63b17d51684c}\label{namespacepwp_ada6a8613896dbbfd6fba63b17d51684c}} 
\index{pwp@{pwp}!get\+\_\+peer\+\_\+id@{get\+\_\+peer\+\_\+id}}
\index{get\+\_\+peer\+\_\+id@{get\+\_\+peer\+\_\+id}!pwp@{pwp}}
\subsubsection{\texorpdfstring{get\+\_\+peer\+\_\+id()}{get\_peer\_id()}}
{\footnotesize\ttfamily void pwp\+::get\+\_\+peer\+\_\+id (\begin{DoxyParamCaption}\item[{string $\ast$}]{id }\end{DoxyParamCaption})}



Put into \char`\"{}id\char`\"{} the string that conrespond to the client ID. 

Find a new way to generate the ID\+:
\begin{DoxyEnumerate}
\item Using M\+AC address.
\item Initially random and then writtend o a file.
\end{DoxyEnumerate}


\begin{DoxyParams}{Parameters}
{\em id} & A pointer to the string that will contains the Peer-\/\+ID \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacepwp_a62060bdcdc80541b0892e26fbeab1e91}\label{namespacepwp_a62060bdcdc80541b0892e26fbeab1e91}} 
\index{pwp@{pwp}!pwp\+\_\+protocol\+\_\+manager@{pwp\+\_\+protocol\+\_\+manager}}
\index{pwp\+\_\+protocol\+\_\+manager@{pwp\+\_\+protocol\+\_\+manager}!pwp@{pwp}}
\subsubsection{\texorpdfstring{pwp\+\_\+protocol\+\_\+manager()}{pwp\_protocol\_manager()}}
{\footnotesize\ttfamily void pwp\+::pwp\+\_\+protocol\+\_\+manager (\begin{DoxyParamCaption}\item[{\hyperlink{structpwp_1_1peer}{pwp\+::peer}}]{peer\+\_\+,  }\item[{const std\+::vector$<$ uint8\+\_\+t $>$ \&}]{handshake,  }\item[{const char $\ast$}]{info\+\_\+hash,  }\item[{\hyperlink{structtorr_1_1Torrent}{Torrent} \&}]{torrent }\end{DoxyParamCaption})}



Manager of the entire P\+WP protocol. 

This is the manager of the entire peer comunication. After creating the socket the handshake is sended. The received handshake is then checked and if it\textquotesingle{}s correct the routine starts.


\begin{DoxyEnumerate}
\item Send Interested Message
\item Send Unchocked Message
\item Start Keep-\/\+Alive Routine
\item Wait (asynchronously) for messages
\item Loop and send appropriate messages
\end{DoxyEnumerate}

\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000002}{Bug}]No timeout control is performed so if there is a dead peer that does not respond the software blocks until the default SO timeout is reacher (tipically 2 minutes).\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em peer\+\_\+} & The peer on which execute the protocol \\
\hline
{\em handshake} & The initial handshake to send \\
\hline
{\em info\+\_\+hash} & The torrent file info\+\_\+hash \\
\hline
{\em torrent} & The struct containing all torrent information \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacepwp_ae8331eb5e3c98deddc6022dad92352f6}\label{namespacepwp_ae8331eb5e3c98deddc6022dad92352f6}} 
\index{pwp@{pwp}!remove\+\_\+invalid\+\_\+peer@{remove\+\_\+invalid\+\_\+peer}}
\index{remove\+\_\+invalid\+\_\+peer@{remove\+\_\+invalid\+\_\+peer}!pwp@{pwp}}
\subsubsection{\texorpdfstring{remove\+\_\+invalid\+\_\+peer()}{remove\_invalid\_peer()}}
{\footnotesize\ttfamily void pwp\+::remove\+\_\+invalid\+\_\+peer (\begin{DoxyParamCaption}\item[{\hyperlink{namespacepwp_ad07fa6df116b205302ad5ec172277184}{pwp\+::\+Peer\+List}}]{peer\+\_\+list }\end{DoxyParamCaption})}



Find invalid peers and remove it. 

\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000001}{Bug}]It does not check for already active peer \end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em peer\+\_\+list} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespacepwp_a851ddc0e8fb2eb0a86317cc944c4a927}\label{namespacepwp_a851ddc0e8fb2eb0a86317cc944c4a927}} 
\index{pwp@{pwp}!send\+\_\+handshake@{send\+\_\+handshake}}
\index{send\+\_\+handshake@{send\+\_\+handshake}!pwp@{pwp}}
\subsubsection{\texorpdfstring{send\+\_\+handshake()}{send\_handshake()}}
{\footnotesize\ttfamily int pwp\+::send\+\_\+handshake (\begin{DoxyParamCaption}\item[{\hyperlink{structpwp_1_1peer__connection}{pwp\+::peer\+\_\+connection} \&}]{peerc\+\_\+t,  }\item[{const std\+::vector$<$ uint8\+\_\+t $>$}]{handshake,  }\item[{std\+::vector$<$ uint8\+\_\+t $>$ \&}]{response }\end{DoxyParamCaption})}

Contact the peer with handshake and download the response

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Error code }&\textbf{ Meaning  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Error code }&\textbf{ Meaning  }\\\cline{1-2}
\endhead
-\/1 &Unimplemented. \\\cline{1-2}
-\/2 &Socket Error. \\\cline{1-2}
-\/3 &Invalid IP Address. \\\cline{1-2}
\end{longtabu}



\begin{DoxyParams}{Parameters}
{\em t\+\_\+peer} & the peer to contact \\
\hline
{\em handshake} & the handshake to send \\
\hline
{\em response} & a pointer to an array used to store the response\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 on success, $<$ 0 on failure 
\end{DoxyReturn}
\mbox{\Hypertarget{namespacepwp_a58c780495f2139a56b95662dc7c0345f}\label{namespacepwp_a58c780495f2139a56b95662dc7c0345f}} 
\index{pwp@{pwp}!verify\+\_\+handshake@{verify\+\_\+handshake}}
\index{verify\+\_\+handshake@{verify\+\_\+handshake}!pwp@{pwp}}
\subsubsection{\texorpdfstring{verify\+\_\+handshake()}{verify\_handshake()}}
{\footnotesize\ttfamily int pwp\+::verify\+\_\+handshake (\begin{DoxyParamCaption}\item[{const vector$<$ uint8\+\_\+t $>$}]{handshake,  }\item[{size\+\_\+t}]{len,  }\item[{const \hyperlink{structpwp_1_1peer}{pwp\+::peer}}]{t\+\_\+peer,  }\item[{const char $\ast$}]{info\+\_\+hash }\end{DoxyParamCaption})}

Verify if an handshake (received) is correct

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Error Code }&\textbf{ Meaning  }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ Error Code }&\textbf{ Meaning  }\\\cline{1-2}
\endhead
-\/1 &First byte is not 19 \\\cline{1-2}
-\/2 &Invalid protocol string \\\cline{1-2}
-\/3 &Info hash does not match (with the one sended) \\\cline{1-2}
-\/4 &Peer ID does not match (Bypassed) \\\cline{1-2}
\end{longtabu}
\begin{DoxyWarning}{Warning}
The comparison of the {\itshape peer-\/\+ID} often fail so it\textquotesingle{}s skipped (no return -\/4)
\end{DoxyWarning}
\begin{DoxyRefDesc}{Bug}
\item[\hyperlink{bug__bug000003}{Bug}]peer-\/\+ID is checked but nothing is done in case of failing\end{DoxyRefDesc}



\begin{DoxyParams}{Parameters}
{\em handshake} & \+: the handshake to check \\
\hline
{\em t\+\_\+peer} & \+: the peer who sended the handshake \\
\hline
{\em info\+\_\+hash} & \+: the info\+\_\+hash of the file \\
\hline
\end{DoxyParams}
If the initiator of the connection receives a handshake in which the peer\+\_\+id does not match the expected peerid, then the initiator is expected to drop the connection. Note that the initiator presumably received the peer information from the tracker, which includes the peer\+\_\+id that was registered by the peer. The peer\+\_\+id from the tracker and in the handshake are expected to match.